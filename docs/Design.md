# Dotfilet Design Document

This document outlines the vision, architecture, and core concepts for Dotfilet, a declarative configuration management tool for macOS (and potentially other operating systems in the future).

## Vision & Guiding Principles

Dotfilet aims to be the **definitive tool for developers** to manage their entire macOS environment declaratively. It treats your machine's configuration as code, allowing it to be versioned, shared, and reliably reproduced across multiple machines.

- **Declarative**: You define the _desired state_ of your system in a config file; Dotfilet figures out how to make it so.

- **Bi-directional Sync is Key**: Unlike most tools, Dotfilet isn't a one-way street. It can **read changes** made manually via GUI or CLI and help you commit them back to your configuration, preventing drift and making it the single source of truth.

- **Extensible by Design**: A robust plugin system is fundamental, allowing the community to add support for any application or aspect of the system.

- **Ergonomics First**: The configuration language and CLI should be intuitive for developers, with great IDE support and clear feedback.

## Core Concepts & Terminology

Understanding these terms is key to the Dotfilet architecture.

- **Plugin**: A self-contained module responsible for managing a single application (e.g., vscode, macos-dock, git). Each plugin knows how to read, write, and validate the configuration for its target.

- **Configuration**: The compiled configuration (e.g. for all plugins) that a user wants to deploy to their machine. Commonly expressed via a collection of [CUE](https://cuelang.org/) files.

- **Variable/Secret**: A value that can be injected into the configuration from an external source (e.g., user prompt, an environment variable, a 1Password value).

- **Host**: A machine that configuration is deployed on. Each host is given a name that the user can refer to (e.g. for overriding configuration).

## User Experience (UX) & Configuration

### CLI Commands

The primary interface is the Dotfilet CLI.

#### `dotfilet init`

Scaffolds a new Dotfilet repository with a sample structure. May ask the user a few questions to customize the environment appropriately.

#### `dotfilet diff`

Reads the current state of the system and displays any changes that it would like to make.

Important flags & arguments:

- `[...resources]`: The user can pass specific resources like `program.vscode` or `macos.security`, or even specific settings like `macos.dock.autohide` to restrict the set of changes to be considered.

- `--plan [PLANFILE]`: Instructs `dotfilet diff` to write its plan to disk.

#### `dotfilet apply`

Applies the configuration from the repo to the local machine. Also implicitly associates and then starts the sync agent.

Important flags & arguments:

- `[...RESOURCES]`: The user can pass specific resources like `program.vscode` or `macos.security`, or even specific settings like `macos.dock.autohide` to restrict the set of changes to be considered.

- `--plan [PLANFILE]`: Consumes a plan file (generated by diff) and applies only those changes.

#### `dotfilet agent associate`

Configures the sync agent to use the configuration located in the current directory (or passed path).

#### `dotfilet agent start`

Starts the sync agent; installing it if needed.

#### `dotfilet agent stop`

Stops the sync agent.

#### `dotfilet agent install`

Installs configuration (e.g. launchd) for the agent to be persistent.

#### `dotfilet agent uninstall`

Removes the agent’s installed configuration.

### Conventional Configuration

While Dotfilet directly accepts a JSON object that expresses the machine configuration, it is more common to express machine configuration as a collection of [CUE](https://cuelang.org/) files following a standard convention.

Dotfilet will discover and load all `.cue` files in a directory, and treat their merged configuration as its own. Users are encouraged—but not required—to follow Dotfilet's conventions:

```
<config root>/
  hosts/  # Overrides for specific machines.
    <host-name>.cue
    …
  <platform>/  # Platform-specific configuration (e.g. for MacOS)
    <category>.cue
    …
  programs/  # Specific programs and their configuration.
    <program>.cue
    …
```

> [!TIP]
>
> Following this convention allows Dotfilet to enable features like [bi-directional sync](#41-sync-agent); but it does not enforce or require that they are followed.

#### `hosts/<host-name>.cue`

A typical host file looks something like:

```cue
// hosts/personal-laptop.cue
if $host == "personal-laptop" {
	programs: {
		"slack": {
			enabled: false
		}
	}
}
```

#### `<platform>/<category>.cue`

Configuration for some aspect of the host's operating system. For example:

```cue
// macos/dock.cue
macos: dock: {
	autohide:    true
	showRecents: false
}
```

#### `programs/<program>.cue`

Configuration for a specific program. For example:

```cue
// programs/google-chrome.cue
programs: "google-chrome": {
	extensions: {
		// Google Docs Offline
		ghbmnnjooekpmoecnnnilnnbdlolhkhi: {}
	}
}
```

#### CUE Environment

Dotfilet injects a few values into the CUE configuration for your convenience:

`$host`: The name of the current host, that configuration is being applied to.

## Architecture

### System Components & Responsibilities

Dotfilet is composed of three main components that work together to manage system configuration declaratively.

#### Dotfilet Core

The core system orchestrates configuration management and serves as the central coordinator.

**Responsibilities:**

- **Configuration Loading**: Discovers and loads CUE files, merges them into a unified configuration, and validates against plugin schemas.

- **State Comparison & Diffing**: Compares desired configuration against actual system state reported by plugins, computing the minimal set of changes needed.

- **Plugin Orchestration**: Manages plugin lifecycle, coordinates parallel execution, and handles inter-plugin dependencies.

- **Variable Resolution**: Resolves configuration variables and prompts users for missing values when needed.

- **Change Minimization**: Ensures only necessary changes are applied to the system, maintaining idempotency across operations.

### Plugin System

Dotfilet's plugin architecture enables extensible management of applications and system components through external processes that communicate via JSON-RPC.

See [Plugin Protocol](./Plugin Protocol.md) for the complete specification of how plugins communicate with the Dotfilet core system.

#### Plugin Discovery & Loading

Dotfilet core automatically discovers and loads plugins based on the configuration keys present in your CUE files:

- **Configuration-Driven Loading**: Plugins are loaded only when their corresponding configuration keys are present. For example, including `programs: "1password": {}` in your configuration triggers loading of the 1Password plugin.

- **Plugin Search Paths**: Dotfilet searches for plugins in multiple locations, allowing both bundled and third-party plugins:
  - **Bundled Plugins**: Core plugins shipped with Dotfilet (e.g., `/usr/local/lib/dotfilet/plugins/`)
  - **User Plugins**: User-installed plugins (e.g., `~/.dotfilet/plugins/`)
  - **Project Plugins**: Repository-specific plugins (e.g., `./.dotfilet/plugins/`)

- **Binary Plugin Format**: Each plugin is a single executable binary organized in a directory structure that mirrors configuration paths:
  ```
  <plugin-search-path>/
    programs/
      1password        # Handles programs.1password.*
      google-chrome    # Handles programs.google-chrome.*
    macos/
      dock             # Handles macos.dock.*
      security         # Handles macos.security.*
  ```

- **Plugin Resolution**: The core maps configuration paths to plugin binaries using a predictable naming convention, searching through all plugin search paths in priority order.

- **Lazy Loading**: Plugins are loaded on-demand when their configuration sections are encountered, minimizing resource usage for unused applications.

#### Plugin Responsibilities

Each plugin manages a specific application or system aspect with clearly defined responsibilities:

- **State Discovery**: Read current system state from authoritative sources (plist files, APIs, config files, etc.) without caching.

- **Configuration Application**: Write configuration changes and handle required side effects (e.g., restarting services).

- **Schema Definition**: Expose CUE schemas for configuration validation and IDE support.

- **Idempotent Operations**: Ensure applying the same configuration multiple times produces identical results.

- **Isolation**: Handle failures gracefully without affecting other plugins.

- **Unknown Config Support**: Handle configuration keys introduced by app updates before plugin updates.

> [!IMPORTANT]
>
> **Handling Race Conditions**
>
> Plugins must use declarative write operations (e.g., `set key X to value Y`) rather than state-dependent operations (e.g., `if key X is Z, then set it to Y`) to ensure final state matches configuration regardless of timing.

#### Sync Agent

The background agent enables bidirectional synchronization between configuration files and system state.

**Responsibilities:**

- **Baseline Establishment**: Read complete system state from all plugins on startup.

- **Change Detection**: Monitor system state through periodic refresh and file system events.

- **Drift Notification**: Emit updates via JSON-RPC when configuration drift is detected.

- **Configuration Writeback**: Update configuration files when changes are made outside of Dotfilet (following conventional file structure).

### Variable System

Dotfilet leverages CUE's tag variable system to inject dynamic values into configuration, enabling flexible, context-aware setups across different machines and environments.

#### CUE Tag Variables

Variables in Dotfilet are implemented using [CUE tag variables](https://cuelang.org/docs/howto/inject-system-information-into-evaluation-using-tag-variable/), which allow external values to be injected during evaluation.

#### Conventional Variables File

Following Dotfilet's convention-over-configuration approach, users should define variables centrally in a `variables.cue` file using the `$variable` syntax:

```cue
// variables.cue - Define all configurable variables
package config

$host: string @tag(host)
$git_username: string @tag(git_username) 
$git_email: string @tag(git_email)
$onepassword_account: string @tag(onepassword_account)
```

These variables can then be referenced throughout your configuration files:

```cue
// hosts/personal-laptop.cue
if $host == "personal-laptop" {
	programs: "slack": {
		enabled: false
	}
}

// programs/git.cue  
programs: git: {
	user: {
		name:  $git_username
		email: $git_email
	}
}
```

#### Variable Resolution & Prompting

When Dotfilet encounters undefined tag variables during configuration evaluation:

1. **Error Detection**: Dotfilet recognizes CUE tag evaluation errors and identifies missing variables.

2. **User Prompting**: Missing variables trigger interactive prompts asking users to provide values.

3. **Value Persistence**: Once provided, variable values are automatically persisted to prevent repeated prompting.

#### Variable Persistence

Variable values are stored using a hierarchical configuration system similar to plugin search paths:

- **Global Variables**: Stored in `~/.dotfilet/variables.json` for user-wide defaults
- **Repository Variables**: Stored in `./.dotfilet/variables.json` for repository-specific overrides
- **Priority Resolution**: Repository-specific variables take precedence over global ones

Example persistence structure:

```json
{
  "host": "personal-laptop",
  "git_username": "John Doe",
  "git_email": "john@example.com",
  "onepassword_account": "my-family"
}
```

This approach ensures variables are resolved consistently across `dotfilet` operations while allowing per-repository customization when needed.

### Configuration Writeback

One of Dotfilet's key differentiators is bidirectional synchronization—the ability to detect changes made to system configuration outside of Dotfilet and write them back to your configuration files. This prevents configuration drift and ensures your repository remains the authoritative source of truth.

#### How Writeback Works

When plugins detect that system state has diverged from the declared configuration, they collaborate with the sync agent to update your CUE files:

1. **Change Detection**: Each plugin monitors the system/application it manages and detects when actual state differs from the last known configuration. Plugins may use shared facilities exposed by the agent (file watching, macOS defaults monitoring, etc.).

2. **Change Emission**: When a plugin detects changes, it emits the configuration paths that need to be updated (e.g., `programs.vscode.settings.theme` or `macos.dock.autohide`).

3. **File Resolution**: The agent receives these configuration path changes and determines which CUE file should be updated based on Dotfilet's conventional directory structure.

4. **Formatting-Preserving Updates**: The agent modifies only the specific configuration values that changed, carefully preserving existing formatting, comments, and file structure in the CUE files.

#### Convention-Based Writeback

Writeback relies on following Dotfilet's [conventional configuration](#conventional-configuration) structure:

- **Platform Changes**: System-level changes (e.g., macOS dock settings) are written to `<platform>/<category>.cue` files.

- **Program Changes**: Application-specific changes are written to `programs/<program>.cue` files.

- **Fallback Files**: Changes that don't fit the conventional directory structure are written to an `overrides.cue` file.

#### User Control

Users can configure writeback behavior:

- **Selective Writeback**: Configure which plugins and configuration keys are eligible for automatic writeback.

- **Writeback Disable**: Disable writeback entirely for users who prefer manual configuration management.

> [!TIP]
>
> Writeback works best when you follow Dotfilet's conventional directory structure. While not required, this convention enables the agent to make targeted, predictable updates to your configuration files.

### Additional Architectural Considerations

- **Secrets**:

  - Must be represented via some special string tokens `<<1pass:secret_id>>`(?) that gets interpolated.

  - Secrets mean there is some sense of dependency resolution required (e.g. cannot sync configuration that relies on vars/secrets until they are present on the system. E.g. cannot use 1password secrets until 1Password is installed / configured)

  - We need some way to wait for the user to configure/unlock these tools

  - Plugins need some way to provide secrets (and other variables?)

  - Are secrets just specially managed variables?

## Appendix

### Open Questions

- **Managed applications**:

  - Should be able to manage application installation via homebrew

  - ^ If someone removes a managed application from the configuration, we should uninstall it

  - Leave room to support other package managers (nix, etc)
