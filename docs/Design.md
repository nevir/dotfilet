# Dotfilet Design Document

This document outlines the vision, architecture, and core concepts for Dotfilet, a declarative configuration management tool for macOS (and potentially other operating systems in the future).

## Vision & Guiding Principles

Dotfilet aims to be the **definitive tool for developers** to manage their entire macOS environment declaratively. It treats your machine's configuration as code, allowing it to be versioned, shared, and reliably reproduced across multiple machines.

- **Declarative:** You define the _desired state_ of your system in a config file; Dotfilet figures out how to make it so.

- **Bi-directional Sync is Key:** Unlike most tools, Dotfilet isn't a one-way street. It can **read changes** made manually via GUI or CLI and help you commit them back to your configuration, preventing drift and making it the single source of truth.

- **Extensible by Design:** A robust plugin system is fundamental, allowing the community to add support for any application or aspect of the system.

- **Ergonomics First:** The configuration language and CLI should be intuitive for developers, with great IDE support and clear feedback.

## Core Concepts & Terminology

Understanding these terms is key to the Dotfilet architecture.

- **Plugin:** A self-contained module responsible for managing a single application (e.g., vscode, macos-dock, git). Each plugin knows how to read, write, and validate the configuration for its target.

- **Configuration:** The compiled configuration (e.g. for all plugins) that a user wants to deploy to their machine. Commonly expressed via a collection of [CUE](https://cuelang.org/) files.

- **Variable/Secret:** A value that can be injected into the configuration from an external source (e.g., user prompt, an environment variable, a 1Password value).

- **Host:** A machine that configuration is deployed on. Each host is given a name that the user can refer to (e.g. for overriding configuration).

## User Experience (UX) & Configuration

### CLI Commands

The primary interface is the Dotfilet CLI.

#### `dotfilet init`

Scaffolds a new Dotfilet repository with a sample structure. May ask the user a few questions to customize the environment appropriately.

#### `dotfilet diff`

Reads the current state of the system and displays any changes that it would like to make.

Important flags & arguments:

- `[...resources]`: The user can pass specific resources like `program.vscode` or `macos.security`, or even specific settings like `macos.dock.autohide` to restrict the set of changes to be considered.

- `--plan [PLANFILE]`: Instructs `dotfilet diff` to write its plan to disk.

#### `dotfilet apply`

Applies the configuration from the repo to the local machine. Also implicitly associates and then starts the sync agent.

Important flags & arguments:

- `[...RESOURCES]`: The user can pass specific resources like `program.vscode` or `macos.security`, or even specific settings like `macos.dock.autohide` to restrict the set of changes to be considered.

- `--plan [PLANFILE]`: Consumes a plan file (generated by diff) and applies only those changes.

#### `dotfilet agent associate`

Configures the sync agent to use the configuration located in the current directory (or passed path).

#### `dotfilet agent start`

Starts the sync agent; installing it if needed.

#### `dotfilet agent stop`

Stops the sync agent.

#### `dotfilet agent install`

Installs configuration (e.g. launchd) for the agent to be persistent.

#### `dotfilet agent uninstall`

Removes the agent’s installed configuration.

### Conventional Configuration

While Dotfilet directly accepts a JSON object that expresses the machine configuration, it is more common to express machine configuration as a collection of [CUE](https://cuelang.org/) files following a standard convention.

Dotfilet will discover and load all `.cue` files in a directory, and treat their merged configuration as its own. Users are encouraged—but not required—to follow Dotfilet's conventions:

```
<config root>/
  hosts/  # Overrides for specific machines.
    <host-name>.cue
    …
  <platform>/  # Platform-specific configuration (e.g. for MacOS)
    <category>.cue
    …
  programs/  # Specific programs and their configuration.
    <program>.cue
    …
```

> [!TIP]
>
> Following this convention allows Dotfilet to enable features like [bi-directional sync](#41-sync-agent); but it does not enforce or require that they are followed.

#### `hosts/<host-name>.cue`

A typical host file looks something like:

```cue
// hosts/personal-laptop.cue
if $host == "personal-laptop" {
	programs: {
		"slack": {
			enabled: false
		}
	}
}
```

#### `<platform>/<category>.cue`

Configuration for some aspect of the host's operating system. For example:

```cue
// macos/dock.cue
macos: dock: {
	autohide:    true
	showRecents: false
}
```

#### `programs/<program>.cue`

Configuration for a specific program. For example:

```cue
// programs/google-chrome.cue
programs: "google-chrome": {
	extensions: {
		// Google Docs Offline
		ghbmnnjooekpmoecnnnilnnbdlolhkhi: {}
	}
}
```

#### CUE Environment

Dotfilet injects a few values into the CUE configuration for your convenience:

`$host`: The name of the current host, that configuration is being applied to.

## Architecture

Misc decisions / thoughts:

- CUE CLI & Agent:
  - Operates on directories/repositories of .cue files
    - Injects CUE schemata for validation
    - Injects variables (e.g. $host) for contextual config
- Plugins:
  - Are external processes that communicate with Dotfilet via JSON-RPC
  - Are responsible with subsets of overall configuration
    - Expose configuration schema (as CUE schemata) for validation
  - Typically translate system/app config using a deterministic approach (e.g. camelCasing keys, etc)
    - and support _unknown_ config values (e.g. introduced during an app update, but before the plugin has been updated to be aware of it)
- Variables are context
  - $host, etc
  - Should be persisted if we prompt the user for them (e.g. when not derived from environment)
- Secrets:
  - Must be represented via some special string tokens `<<1pass:secret_id>>`(?) that gets interpolated.
  - Secrets mean there is some sense of dependency resolution required (e.g. cannot sync configuration that relies on vars/secrets until they are present on the system. E.g. cannot use 1password secrets until 1Password is installed / configured)
  - We need some way to wait for the user to configure/unlock these tools
  - Plugins need some way to provide secrets (and other variables?)
  - Are secrets just specially managed variables?
- Configuration writeback
  - Convention over configuration
    - Rely on a standard .cue file structure to write back to that by default
    - If the convention can’t be followed, have some failsafe (“overrides.cue” or something?)

## Protocols

### Plugin JSON-RPC Protocol

[Details to be added from #12](https://github.com/nevir/dotfilet/issues/12)

Misc:

- Document similarly to the [LSP](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/)
- Only websocket? Support both websocket + synchronous?

Methods (names TBD):

- Server -> Plugin:
  - `describeConfig`: Reports all known supported configuration values and their ranges (as JSON schema? CUE schemata?)
  - `getConfig`: Retrieves the current (remote) configuration; possibly with a narrowed set of config values
  - `applyConfig`: Idempotently applies the requested configuration.
  - `subscribeToRemoteChanges`: Requests that the plugin watch for changes and report them back via `remoteChanges` messages.
  - `fileSystemChanges`: Reports any files that have changed and the matching expression(s) that were subscribed to.
- Plugin -> Server:
  - `remoteChanges`: Sends any configuration values that were changed out of band.
  - `subscribeToFilesystem`: Asks the server to perform file system watching on specific paths

## Security

### Security Model

[Details to be added from #14](https://github.com/nevir/dotfilet/issues/14)

## Error Handling & Reporting

[Details to be added from #11](https://github.com/nevir/dotfilet/issues/11)

## Appendix

### Plugin Prototype Ideas

[Details to be added from #13](https://github.com/nevir/dotfilet/issues/13)

### Open Questions

- Managed applications
  - Should be able to manage application installation via homebrew
  - ^ If someone removes a managed application from the configuration, we should uninstall it
  - Leave room to support other package managers (nix, etc)
