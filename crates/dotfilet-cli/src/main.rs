use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "dotfilet")]
#[command(about = "A declarative configuration management tool for developer environments")]
#[command(version)]
struct Cli {
    #[command(flatten)]
    global: GlobalArgs,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Parser)]
struct GlobalArgs {
    #[arg(long, global = true, help = "Enable verbose output")]
    verbose: bool,

    #[arg(long, global = true, help = "Perform a dry run without making changes")]
    dry_run: bool,
}

#[derive(Subcommand)]
enum Commands {
    #[command(about = "Scaffold a new Dotfilet repository")]
    Init,

    #[command(about = "Display pending configuration changes")]
    Diff {
        #[arg(help = "Specific resources to check for changes")]
        resources: Vec<String>,
    },

    #[command(about = "Apply configuration changes to the system")]
    Apply {
        #[arg(help = "Specific resources to apply")]
        resources: Vec<String>,
        
        #[arg(long, help = "Use a plan file generated by diff")]
        plan: Option<String>,
    },

    #[command(about = "Manage the sync agent")]
    Agent {
        #[command(subcommand)]
        command: AgentCommands,
    },
}

#[derive(Subcommand)]
enum AgentCommands {
    #[command(about = "Configure the sync agent to use current configuration")]
    Associate,

    #[command(about = "Start the sync agent")]
    Start,

    #[command(about = "Stop the sync agent")]
    Stop,
}

fn main() {
    let cli = Cli::parse();

    match cli.command {
        Commands::Init => {
            println!("dotfilet init: Not yet implemented");
            println!("This command will scaffold a new Dotfilet repository with sample configuration");
        }

        Commands::Diff { resources } => {
            if resources.is_empty() {
                println!("dotfilet diff: Not yet implemented");
                println!("This command will show all pending configuration changes");
            } else {
                println!("dotfilet diff: Not yet implemented");
                println!("This command will show pending changes for: {}", resources.join(", "));
            }
        }

        Commands::Apply { resources, plan } => {
            match (resources.is_empty(), plan) {
                (true, None) => {
                    println!("dotfilet apply: Not yet implemented");
                    println!("This command will apply all configuration changes");
                }
                (false, None) => {
                    println!("dotfilet apply: Not yet implemented");
                    println!("This command will apply changes for: {}", resources.join(", "));
                }
                (_, Some(plan_file)) => {
                    println!("dotfilet apply: Not yet implemented");
                    println!("This command will apply changes from plan file: {}", plan_file);
                }
            }
        }

        Commands::Agent { command } => {
            match command {
                AgentCommands::Associate => {
                    println!("dotfilet agent associate: Not yet implemented");
                    println!("This command will configure the sync agent for the current directory");
                }
                AgentCommands::Start => {
                    println!("dotfilet agent start: Not yet implemented");
                    println!("This command will start the sync agent daemon");
                }
                AgentCommands::Stop => {
                    println!("dotfilet agent stop: Not yet implemented");
                    println!("This command will stop the sync agent daemon");
                }
            }
        }
    }

    if cli.global.verbose {
        eprintln!("Verbose mode enabled");
    }

    if cli.global.dry_run {
        eprintln!("Dry run mode enabled - no changes will be made");
    }
}
