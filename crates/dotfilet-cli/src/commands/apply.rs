use clap::Parser;
use crate::styles::get_custom_styles;

#[derive(Parser)]
#[command(about = "Apply configuration changes to the system")]
#[command(
    long_about = "Apply your Dotfilet configuration to the current system, making all
necessary changes to bring the system state in line with your declared configuration.
This automatically starts the sync agent after successful application."
)]
#[command(after_help = "Examples:
    dotfilet apply                    Apply all configuration changes
    dotfilet apply programs.vscode    Apply only VS Code configuration
    dotfilet apply --plan changes.json   Apply changes from a plan file
    dotfilet apply macos.dock programs.chrome   Apply multiple specific resources
    
Workflow:
    1. dotfilet diff                  Preview changes first
    2. dotfilet apply                 Apply the changes
    3. Agent starts automatically     Background sync begins")]
#[command(styles = get_custom_styles())]
pub struct ApplyCommand {
    #[arg(help = "Specific resources to apply (e.g., programs.vscode, macos.dock)")]
    pub resources: Vec<String>,

    #[arg(
        long,
        value_name = "FILE",
        help = "Apply changes from a plan file generated by diff"
    )]
    pub plan: Option<String>,
}

impl ApplyCommand {
    pub fn execute(self) {
        // Basic validation for plan file
        if let Some(ref plan_file) = self.plan {
            if !std::path::Path::new(plan_file).exists() {
                eprintln!("❌ Error: Plan file '{}' does not exist.", plan_file);
                eprintln!();
                eprintln!("💡 Tips:");
                eprintln!("   • Check the file path for typos");
                eprintln!(
                    "   • Generate a plan file with: dotfilet diff --plan {}",
                    plan_file
                );
                eprintln!("   • Ensure you're in the correct directory");
                std::process::exit(1);
            }
        }

        // Basic validation for resource names
        for resource in &self.resources {
            if resource.is_empty() {
                eprintln!("❌ Error: Empty resource name is not allowed.");
                eprintln!();
                eprintln!("💡 Valid resource examples:");
                eprintln!("   • programs.vscode");
                eprintln!("   • macos.dock");
                eprintln!("   • programs.chrome.settings");
                std::process::exit(1);
            }

            // Basic format validation
            if !resource.contains('.')
                && !resource
                    .chars()
                    .all(|c| c.is_alphanumeric() || c == '_' || c == '-')
            {
                eprintln!(
                    "❌ Warning: Resource '{}' may not follow expected naming conventions.",
                    resource
                );
                eprintln!("   Expected format: category.name or category.name.subcategory");
                eprintln!();
            }
        }

        match (self.resources.is_empty(), self.plan) {
            (true, None) => {
                println!("🚧 Command not yet implemented");
                println!();
                println!("When ready, this command will:");
                println!("  • Apply all configuration changes to bring system into desired state");
                println!("  • Execute changes safely with proper error handling and rollback");
                println!("  • Automatically start the sync agent after successful application");
                println!("  • Provide detailed progress and confirmation of changes made");
                println!();
                println!("💡 Tip: Run 'dotfilet diff' first to preview what changes will be made.");
            }
            (false, None) => {
                println!("🚧 Command not yet implemented");
                println!();
                println!("When ready, this command will apply changes for:");
                for resource in &self.resources {
                    println!("  • {}", resource);
                }
                println!();
                println!("Resource filtering allows you to apply configuration incrementally.");
            }
            (_, Some(plan_file)) => {
                println!("🚧 Command not yet implemented");
                println!();
                println!("When ready, this command will:");
                println!("  • Load the plan file: {}", plan_file);
                println!("  • Apply only the changes specified in the plan");
                println!("  • Provide safe, reproducible configuration deployment");
                println!();
                println!("Plan files enable precise control over which changes to apply.");
            }
        }
    }
}