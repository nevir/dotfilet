use crate::styles;
use crate::styles::CUSTOM_STYLES;
use crate::styles::{HEADER, LITERAL};
use clap::Parser;

#[derive(Parser)]
#[command(about = styles::about("Apply configuration changes to the system"))]
#[command(
    long_about = styles::long_about("Apply your Dotfilet configuration to the current system, making all
necessary changes to bring the system state in line with your declared configuration.
This automatically starts the sync agent after successful application.")
)]
#[command(after_help = format!( "{HEADER}Examples{HEADER:#}:
    {LITERAL}dotfilet apply{LITERAL:#}                    Apply all configuration changes
    {LITERAL}dotfilet apply programs.vscode{LITERAL:#}    Apply only VS Code configuration
    {LITERAL}dotfilet apply --plan changes.json{LITERAL:#}   Apply changes from a plan file
    {LITERAL}dotfilet apply macos.dock programs.chrome{LITERAL:#}   Apply multiple specific resources

{HEADER}Workflow{HEADER:#}:
    1. {LITERAL}dotfilet diff{LITERAL:#}                  Preview changes first
    2. {LITERAL}dotfilet apply{LITERAL:#}                 Apply the changes
    3. {LITERAL}Agent starts automatically{LITERAL:#}     Background sync begins" ))]
#[command(styles = CUSTOM_STYLES)]
pub struct ApplyCommand {
    #[arg(help = "Specific resources to apply (e.g., programs.vscode, macos.dock)")]
    pub resources: Vec<String>,

    #[arg(
        long,
        value_name = "FILE",
        help = "Apply changes from a plan file generated by diff"
    )]
    pub plan: Option<String>,
}

impl ApplyCommand {
    pub fn execute(self) {
        // Basic validation for plan file
        if let Some(ref plan_file) = self.plan {
            if !std::path::Path::new(plan_file).exists() {
                eprintln!("âŒ Error: Plan file '{}' does not exist.", plan_file);
                eprintln!();
                eprintln!("ðŸ’¡ Tips:");
                eprintln!("   â€¢ Check the file path for typos");
                eprintln!(
                    "   â€¢ Generate a plan file with: dotfilet diff --plan {}",
                    plan_file
                );
                eprintln!("   â€¢ Ensure you're in the correct directory");
                std::process::exit(1);
            }
        }

        // Basic validation for resource names
        for resource in &self.resources {
            if resource.is_empty() {
                eprintln!("âŒ Error: Empty resource name is not allowed.");
                eprintln!();
                eprintln!("ðŸ’¡ Valid resource examples:");
                eprintln!("   â€¢ programs.vscode");
                eprintln!("   â€¢ macos.dock");
                eprintln!("   â€¢ programs.chrome.settings");
                std::process::exit(1);
            }

            // Basic format validation
            if !resource.contains('.')
                && !resource
                    .chars()
                    .all(|c| c.is_alphanumeric() || c == '_' || c == '-')
            {
                eprintln!(
                    "âŒ Warning: Resource '{}' may not follow expected naming conventions.",
                    resource
                );
                eprintln!("   Expected format: category.name or category.name.subcategory");
                eprintln!();
            }
        }

        match (self.resources.is_empty(), self.plan) {
            (true, None) => {
                println!("ðŸš§ Command not yet implemented");
                println!();
                println!("When ready, this command will:");
                println!("  â€¢ Apply all configuration changes to bring system into desired state");
                println!("  â€¢ Execute changes safely with proper error handling and rollback");
                println!("  â€¢ Automatically start the sync agent after successful application");
                println!("  â€¢ Provide detailed progress and confirmation of changes made");
                println!();
                println!("ðŸ’¡ Tip: Run 'dotfilet diff' first to preview what changes will be made.");
            }
            (false, None) => {
                println!("ðŸš§ Command not yet implemented");
                println!();
                println!("When ready, this command will apply changes for:");
                for resource in &self.resources {
                    println!("  â€¢ {}", resource);
                }
                println!();
                println!("Resource filtering allows you to apply configuration incrementally.");
            }
            (_, Some(plan_file)) => {
                println!("ðŸš§ Command not yet implemented");
                println!();
                println!("When ready, this command will:");
                println!("  â€¢ Load the plan file: {}", plan_file);
                println!("  â€¢ Apply only the changes specified in the plan");
                println!("  â€¢ Provide safe, reproducible configuration deployment");
                println!();
                println!("Plan files enable precise control over which changes to apply.");
            }
        }
    }
}
